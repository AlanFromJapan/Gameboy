
/*************************
**
** Autogenerated stub for basic program that just displays the first Map.
** Made by GbReaper at 3/21/2020 8:44:00 AM
** AlanFromJapan - https://electrogeek.cc
**
*/

#include <gb/gb.h>
#include <gb/drawing.h>

#include "my_lib01.h"
#include "Map_Intro.h"
#include "Map_Title.h"
#include "transitions.h"
#include "graphics.h"
#include "inputs.h"
#include "windows.h"


#define RUN_TESTS

#ifdef RUN_TESTS
#include "tests.h"
#endif //RUN_TESTS

#define SCREENW         GRAPHICS_WIDTH
#define SCREENH         GRAPHICS_HEIGHT
#define HSCROLLLEFT     32
#define HSCROLLRIGHT    128


unsigned int x = 50;
unsigned int y = 50;

unsigned int stepCount = 0;

unsigned char *currentMap;
unsigned int currentMapW_Tile = 20;
unsigned int currentMapH_Tile = 18;

//List of tiles that are considered as not-walkable (should be the first ones or the last ones for performance sake)
#define COLLISION_TILE_LEN  25
UINT8 const COLLISION_TILE[] = {
TILE_SAPIN_NW, TILE_SAPIN_NE, TILE_SAPIN_SW, TILE_SAPIN_SE, 
TILE_PALMTREE_NW, TILE_PALMTREE_NE, TILE_PALMTREE_SW, TILE_PALMTREE_SE,
TILE_PALMTREE_NW, TILE_PALMTREE_NE, TILE_PALMTREE_SW, TILE_PALMTREE_SE,
TILE_ROCK_NW, TILE_ROCK_NE, TILE_ROCK_SW, TILE_ROCK_SE, 
TILE_COLUMN_NW, TILE_COLUMN_NE, TILE_COLUMN_SW, TILE_COLUMN_SE, 
TILE_TOWER_1, TILE_TOWER_2, TILE_TOWER_3, TILE_TOWER_4, TILE_TOWER_5
};

//List of transition tiles: walk on it but do something special
#define TRANSITION_TILE_LEN     12
UINT8 const TRANSITION_TILE[] = {
TILE_DOOR_NW, TILE_DOOR_NE, TILE_DOOR_SW, TILE_DOOR_SE,
TILE_STAIRS_UP_NW, TILE_STAIRS_UP_NE, TILE_STAIRS_UP_SW, TILE_STAIRS_UP_SE, 
TILE_STAIRS_DOWN_NW, TILE_STAIRS_DOWN_NE, TILE_STAIRS_DOWN_SW, TILE_STAIRS_DOWN_SE
};


//Move the Hero to x,y
#define MV_HERO(x,y)    move_sprite(0, x, y); move_sprite(1, x+8, y);
//Returns the background tile at XX,YY
#define GET_BG_TILE(XX, YY)     (currentMap[(YY / 8) * currentMapW_Tile + (XX / 8)])
//Returns the position of the player on the map (different than on the screen!)
#define GET_MAP_X(dx)   (bgx + x + (dx * (INT8)8)) /* +8 because x is in the middle of the 16x16 */
#define GET_MAP_Y(dy)   (bgy + y + dy -8) /* -8 to put the collision detection center of the body */

//Results of the checkCollision()
#define MOVE_CHECK_OK           0
#define MOVE_CHECK_COLLISION    1
#define MOVE_CHECK_TRANSITION   2
UINT8 lastMoveCheck = MOVE_CHECK_OK;


/**
 * Check if collision, return 0 if no collision and edits the delta x & y, 1 if collision, 2 if transition
 */
UINT8 inline checkCollision (INT8 *dx, INT8 *dy){
    //x,y are in the bottom-middle of the Sprite
    UINT8 nx = GET_MAP_X(*dx);
    UINT8 ny = GET_MAP_Y(*dy);

    UINT8 tile = GET_BG_TILE(nx, ny);

    unsigned int i =0;
    for (; i < COLLISION_TILE_LEN; i++){
        if (tile == COLLISION_TILE[i]){
            //collision
            *dx = 0;
            *dy = 0;
            return MOVE_CHECK_COLLISION;
        }

        if (i < TRANSITION_TILE_LEN){
            //not sure optimizer left-right
            if (tile == TRANSITION_TILE[i]){
                return MOVE_CHECK_TRANSITION;
            }

        }
    }
    //all good
    return MOVE_CHECK_OK;
}

/**
 * Vertical blank interrupt: where we "draw" memory while screen is not updated
 */
void vblint(){
    move_bkg(bgx, bgy);

    MV_HERO(x, y);

}

/**
 * Map transition: small anim and load new bg
 * 
 */
void doMapTransition(){
    HIDE_BKG;
    delay (500);
    HIDE_SPRITES;
    delay (500);

    //LOAD!
    mapTransition(
        &currentMap, 
        &x, 
        &y, 
        &currentMapW_Tile, 
        &currentMapH_Tile
        );

    if (currentMapW_Tile >= 20) {
        //if wider than a screen, align left
        bgx=0;
    }
    else {

        bgx = (SCREENW - currentMapW_Tile * 8) / 2 ;
        x += bgx;
        bgx = 255 - bgx;        
    }
    

    //centers the new map vertically in the screen (no vertical scroll)
    bgy = (SCREENH - currentMapH_Tile * 8) / 2 ;
    y += bgy;
    bgy = 32*8 - bgy; 
    

    vblint();

    SHOW_SPRITES;
    delay (500);
    SHOW_BKG;
    delay (500);

}


/**
 * Shows title screen
 * 
 */
void showTitle(){
    set_bkg_tiles(0, 0, Map_Title_WIDTH, Map_Title_HEIGHT, Map_Title);
    SHOW_BKG;

    while(1) {
        lastJoypad = joypad();
        if(lastJoypad & J_START) {
            break;
        }
        delay(10);
    }

    //debouncing
    delay(200);
}



/**
 * Shows the first map at beginning, after is all transitions
 */
inline void showInitialMap(){
    set_bkg_tiles(bgx, bgy, Map_Intro_WIDTH, Map_Intro_HEIGHT, Map_Intro);
    currentMap = Map_Intro;
    currentMapW_Tile = Map_Intro_WIDTH;
    currentMapH_Tile = Map_Intro_HEIGHT;
}

/**
 * Displays a fullscreen scroller for the story intro.
 * 
 */
inline void showStartupScroller(){
    HIDE_BKG;

    mapMakeVerticalMessage(&currentMap, TILE_EMPTY);
    currentMapW_Tile = 20;
    currentMapH_Tile = 32;

    writetextBG(1,1, "Dans un future    lointain, le monde a ete ravage par une etrange maladie.Tous les humains ont disparu peu apeu, laissant une terre vide qui retomba petit a petitdans un monde moyenageux ou la  technologie a ete oubliee.");
    writetextBG(1,14, "Notre hero part a la recherche de laverite, se basant sur des legendes  parlant d un mage qui vivait dans   une tour cachee   dans la foret...");

    set_bkg_tiles(bgx, bgy, currentMapW_Tile, currentMapH_Tile, currentMap);

    SHOW_BKG;
    UINT8 vy =180;

    while(1) {
        
        if (vy >= 180 || vy <100) {
            move_bkg(0, vy++);
            delay(100);
        }
        else {
            delay(3000);
            break;
        }
    }

}


/**
 * MAIN method
 */
void main() {
  
    SPRITES_8x16;

    set_sprite_data(0, my_lib01_COUNT, my_lib01);
    set_bkg_data(0, my_lib01_COUNT, my_lib01);

    //Shows the title screen
    showTitle();

    //TEST
#ifdef RUN_TESTS    
    //test_text();
#endif

    //Intro scroller
//    showStartupScroller();

    //show the landing map
    showInitialMap();

    //make the hero and move to start point
    set_sprite_tile(0, TILE_HERO_NW);
    set_sprite_tile(1, TILE_HERO_NE);
    
    MV_HERO(x, y);
    
    SHOW_BKG;
    SHOW_SPRITES;

    wait_vbl_done();
    //branch interrup handler for VBlank
    add_VBL(vblint);

    while(1) {
        INT8 dx = 0;
        INT8 dy = 0;

        lastJoypad = joypad();
        if(lastJoypad & J_RIGHT && x < SCREENW-8) {
            dx=1;
        }
        if(lastJoypad & J_LEFT && x > 8) {
            dx = -1;
        }
        if(lastJoypad & J_UP && y > 16) {
            dy = -1;
        }
        if(lastJoypad & J_DOWN && y < SCREENH) {
            dy = 1;
        }

        //TEST
#ifdef RUN_TESTS    
        if(lastJoypad & J_SELECT) {
            doMapTransition();
        }
        if(lastJoypad & J_START) {
            test_windows();
        }
#endif 

        lastMoveCheck = checkCollision (&dx, &dy);

        if (lastMoveCheck == MOVE_CHECK_TRANSITION){
            //transition!
            doMapTransition();
        }
        else {
            //move or collide
            x += dx;
            y += dy;

            //move bg Left ? only on big maps
            if (dx > 0 && currentMapW_Tile * 8 > SCREENW && bgx < (currentMapW_Tile * 8 - SCREENW) &&  x > HSCROLLRIGHT) {
                x--;
                bgx ++;

            }
            else {
                //move bg Right ? only on big maps
                if (currentMapW_Tile * 8 > SCREENW && bgx > 0  &&  x < HSCROLLRIGHT) {
                    x++;
                    bgx --;
                }
            }

            //moved? change appearance
            if (dx != 0 || dy != 0){
                stepCount++;    

                if ((stepCount & 0x01) == 0){
                    set_sprite_tile(0, TILE_HERO_NW);
                    set_sprite_tile(1, TILE_HERO_NE);
                }
                else {
                    set_sprite_tile(0, TILE_HERO2_NW);
                    set_sprite_tile(1, TILE_HERO2_NE);
                }

            }
        }

        //debouncing on the cheap
        delay(10);


    }
}


